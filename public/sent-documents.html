<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ù…Ø±Ø³Ù„</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.rtl.min.css"
      rel="stylesheet"
    />
    <style>
      #pagination button {
        padding: 6px 12px;
        margin: 0 5px;
        font-size: 14px;
        cursor: pointer;
      }

      #pagination button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #page-info {
        font-weight: bold;
        margin: 0 10px;
      }

      @media print {
        body * {
          visibility: hidden;
        }
        #printableArea,
        #printableArea * {
          visibility: visible;
        }
        #printableArea {
          position: absolute;
          left: 0;
          top: 0;
          width: 100%;
        }
      }
    </style>
  </head>
  <body class="p-4">
    <div class="container">
      <h3>Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ù…Ø±Ø³Ù„</h3>

      <!-- Search Filters -->
      <div class="row mb-3" no-print>
        <div class="col-md-3">
          <label>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø¡</label>
          <input type="date" id="startDate" class="form-control" />
        </div>
        <div class="col-md-3">
          <label>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡</label>
          <input type="date" id="endDate" class="form-control" />
        </div>
        <div class="col-md-3">
          <label>Ø§Ù„ÙˆØ¬Ù‡Ø©</label>
          <select class="form-control" id="adminFilterContainer">
            <option value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª</option>
          </select>
        </div>

        <div class="col-md-3 align-self-end">
          <button id="searchBtn" class="btn btn-primary">Ø¨Ø­Ø«</button>
        </div>

        <div class="d-flex justify-content-between gap-2 mt-3">
          <button id="printReport" class="btn btn-outline-success">
            ğŸ–¨ï¸ Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ±
          </button>
          <!-- <button id="downloadReport" class="btn btn-outline-primary">
          ğŸ“„ ØªØ­Ù…ÙŠÙ„ ØªÙ‚Ø±ÙŠØ± PDF
        </button> -->
          <a href="index.html" class="btn btn-secondary"
            >â¬… Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…</a
          >
        </div>
      </div>

      <!-- Sent Documents Table -->
      <div id="printableArea">
        <table class="table table-bordered mt-2">
          <thead>
            <tr>
              <th>Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹</th>
              <th>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡</th>
              <th>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ø±Ø³Ø§Ù„</th>
              <th>Ø§Ù„ÙˆØ¬Ù‡Ø§Øª</th>
            </tr>
          </thead>
          <tbody id="sentTable"></tbody>
        </table>
      </div>
      <div id="pagination" style="text-align: center; margin-top: 20px">
        <button id="prev-btn">Ø§Ù„Ø³Ø§Ø¨Ù‚</button>
        <span
          >ØµÙØ­Ø©
          <input
            type="number"
            id="page-input"
            style="width: 50px; text-align: center"
            min="1"
          />
          Ù…Ù† <span id="total-pages">1</span></span
        >
        <button id="next-btn">Ø§Ù„ØªØ§Ù„ÙŠ</button>
      </div>
    </div>

    <script>
      const token = localStorage.getItem("token");
      if (!token) location.href = "login.html";

      let destinationCache = {};
      let filteredDocuments = [];
      let pageDocuments = [];

      let currentPage = 1;
      let totalPages = 1;
      let allDestinations = [];

      const sentTable = document.getElementById("sentTable");
      const groupFilter = document.getElementById("adminFilterContainer");
      const prevBtn = document.getElementById("prev-btn");
      const nextBtn = document.getElementById("next-btn");
      const pageInput = document.getElementById("page-input");
      const totalPagesSpan = document.getElementById("total-pages");

      // -----------------------
      // Load all destinations for filter
      // -----------------------
      async function loadAllDestinations() {
        const groupSet = new Set();
        let page = 1;
        let totalPages = 1;

        do {
          const res = await fetch(`/api/documents/sent?page=${page}`, {
            headers: { Authorization: "Bearer " + token },
          });

          const result = await res.json();
          totalPages = result.total_pages;

          for (const doc of result.data) {
            const dests = await loadDestinationsForDoc(doc.id);
            dests.forEach((d) => groupSet.add(d));
          }

          page++;
        } while (page <= totalPages);

        groupFilter.innerHTML = `<option value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª</option>`;
        [...groupSet].sort().forEach((name) => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          groupFilter.appendChild(opt);
        });
      }

      function applyFilter() {
        const selectedGroup = groupFilter.value;

        filteredDocuments = pageDocuments.filter((doc) => {
          const dests = destinationCache[doc.id] || [];
          return !selectedGroup || dests.includes(selectedGroup);
        });

        renderTable();
      }
      // -----------------------
      // Load documents for current page
      // -----------------------
      async function loadSentDocs(page = 1) {
        try {
          const destination = groupFilter.value;

          const params = new URLSearchParams({
            page,
            destination,
          });

          const res = await fetch(`/api/documents/sent?${params}`, {
            headers: { Authorization: "Bearer " + token },
          });

          if (!res.ok) throw new Error("Failed to load");

          const result = await res.json();

          pageDocuments = result.data;
          currentPage = result.page;
          totalPages = result.total_pages;

          renderTable();
          updatePagination();
        } catch (err) {
          console.error(err);
          alert("Network error");
        }
      }

      async function loadDestinationsForPage() {
        destinationCache = {};

        for (const doc of pageDocuments) {
          try {
            const res = await fetch(`/api/documents/${doc.id}/destinations`, {
              headers: { Authorization: "Bearer " + token },
            });

            const dests = await res.json();

            destinationCache[doc.id] = Array.isArray(dests)
              ? dests.map((d) => d.name)
              : [];
          } catch (err) {
            destinationCache[doc.id] = [];
            console.error(err);
          }
        }
      }

      async function loadDestinationsForDoc(docId) {
        if (destinationCache[docId]) {
          return destinationCache[docId];
        }

        const res = await fetch(`/api/documents/${docId}/destinations`, {
          headers: { Authorization: "Bearer " + token },
        });

        if (!res.ok) return [];

        const data = await res.json();

        // normalize response
        const names = Array.isArray(data) ? data.map((d) => d.name) : [];

        destinationCache[docId] = names;
        return names;
      }
      // -----------------------
      // Render table with filter
      // -----------------------
      function renderTable() {
        sentTable.innerHTML = "";

        if (pageDocuments.length === 0) {
          sentTable.innerHTML = `
      <tr>
        <td colspan="4" class="text-center">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬</td>
      </tr>`;
          return;
        }

        for (const doc of pageDocuments) {
          sentTable.innerHTML += `
      <tr>
        <td>${doc.title}</td>
        <td>${new Date(doc.created_at).toLocaleString()}</td>
        <td>${new Date(doc.sent_at).toLocaleString()}</td>
        <td>${doc.destinations}</td>
      </tr>`;
        }
      }
      // -----------------------
      // Pagination
      // -----------------------
      function updatePagination() {
        totalPagesSpan.innerText = totalPages;
        pageInput.value = currentPage;
        prevBtn.disabled = currentPage <= 1;
        nextBtn.disabled = currentPage >= totalPages;
      }

      prevBtn.addEventListener("click", () => {
        if (currentPage > 1) loadSentDocs(currentPage - 1);
      });
      nextBtn.addEventListener("click", () => {
        if (currentPage < totalPages) loadSentDocs(currentPage + 1);
      });
      pageInput.addEventListener("change", (e) => {
        let p = parseInt(e.target.value);
        if (p >= 1 && p <= totalPages) loadSentDocs(p);
        else e.target.value = currentPage;
      });

      // -----------------------
      // Filter dropdown change
      // -----------------------
      groupFilter.addEventListener("change", loadSentDocs(1));

      // -----------------------
      // Search button
      // -----------------------
      document
        .getElementById("searchBtn")
        .addEventListener("click", () => loadSentDocs(1));

      // -----------------------
      // Initial load
      // -----------------------

      loadAllDestinations();
      loadSentDocs(1);

      // // Download PDF report
      // document
      //   .getElementById("downloadReport")
      //   .addEventListener("click", async () => {
      //     const start = document.getElementById("startDate").value;
      //     const end = document.getElementById("endDate").value;
      //     let url = "/api/documents/sent/report";
      //     const params = [];
      //     if (start) params.push(`start=${start}`);
      //     if (end) params.push(`end=${end}`);
      //     if (params.length) url += "?" + params.join("&");

      //     // download by creating an anchor
      //     const a = document.createElement("a");
      //     a.href = url;
      //     a.target = "_blank";
      //     a.rel = "noopener";
      //     // include token via header by fetching blob then creating object URL
      //     try {
      //       const res = await fetch(url, {
      //         headers: { Authorization: "Bearer " + token },
      //       });
      //       if (!res.ok) {
      //         alert("Failed to generate report");
      //         return;
      //       }
      //       const blob = await res.blob();
      //       const blobUrl = URL.createObjectURL(blob);
      //       const dl = document.createElement("a");
      //       dl.href = blobUrl;
      //       dl.download = "sent-documents-report.pdf";
      //       document.body.appendChild(dl);
      //       dl.click();
      //       dl.remove();
      //       URL.revokeObjectURL(blobUrl);
      //     } catch (err) {
      //       console.error(err);
      //       alert("Network error while generating report");
      //     }
      //   });

      fetch("/api/users/me", {
        headers: { Authorization: "Bearer " + token },
      })
        .then((res) => {
          if (!res.ok) {
            logout();
            return;
          }
          return res.json();
        })
        .then((data) => {})
        .catch((err) => {
          console.error(err);
          logout();
        });

      document.getElementById("printReport").addEventListener("click", () => {
        // Make sure the table is fully loaded
        console.log("Printing report for", pageDocuments.length, "documents");
        if (!pageDocuments.length) {
          alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©");
          return;
        }
        window.print();
      });
    </script>
  </body>
</html>
